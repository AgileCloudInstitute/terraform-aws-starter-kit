## Copyright 2020 Green River IT (GreenRiverIT.com) as described in LICENSE.txt distributed with this project on GitHub.  
## Start at https://github.com/AgileCloudInstitute?tab=repositories    

import deploymentFunctions as depfunc
import os
from distutils.dir_util import copy_tree
from pathlib import Path
import platform
import shutil
import sys

<<<<<<< HEAD
#############################################################################
### Import path locations relative to application root
#############################################################################
app_parent_path = os.path.dirname(os.path.realpath("..\\"))
dirOfYamlFile = app_parent_path+"\\config-and-secrets-outside-app-path\\" + "vars\\yamlInputs\\"
nameOfYamlConfigFile = 'demoConfig.yaml'
nameOfYamlKeysFile = 'keys.yaml'
yamlKeysFileAndPath = dirOfYamlFile + nameOfYamlKeysFile 
pathToApplicationRoot = ''  

tfvarsFileAndPath=''

#############################################################################
### Import variable values, including CLI arguments if from pipeline
#############################################################################
if platform.system() == 'Windows':
  dirOfTfvarsFile = app_parent_path+"\\config-and-secrets-outside-app-path\\vars\\VarsForTerraform\\"
  nameOfTfvarsFile = 'keys.tfvars'
  tfvarsFileAndPath = dirOfTfvarsFile + nameOfTfvarsFile

else:
  #Consider whether to give a separate variable for the name of each secret file, as in the next line, or alternatively to repopulate the same variable each time as shown in the line that follows the next line.  
  tfvarsFileAndPath = '/home/azureuser/' + 'foundationSecrets.tfvars'

#The following 7 variables only need to be declared if a pipeline ingests this.  Some of the following will be repopulated by the pipeline inputs.  
keySource=''
yamlConfigFileAndPath = ""
pub = "empty"
sec = "empty"
resourceGroupName="pipeline-resources" 
storageAccountName=''
storageContainerName="tfcontainer"
demoStorageKey=''

#Ingest pipeline variables if they are present
=======
#Dummy key values that will be replaced by pipeline inputs
pub = "empty"
sec = "empty"

>>>>>>> ac0a3b861b45a7306429e91c3896cc8010db9031
print("len(sys.argv) is: ", len(sys.argv))
if len(sys.argv) > 1:  
  keySource=sys.argv[1]
  if keySource != "keyVault":
    print("keySource is NOT set to a valid value.  ")
<<<<<<< HEAD
  # the build config distributed with this repo put the yaml file in the following location for use by pipelines:
  nameOfYamlConfigFile=sys.argv[2]
  pub=sys.argv[3]
  sec=sys.argv[4]
  storageAccountName=sys.argv[5]
  demoStorageKey=sys.argv[6]
  #Next we make the path to application root depend on the DefaultWorkingDirectory from the pipeline agent.  Assuming a linux agent
  pathToApplicationRoot=sys.argv[7] + '/_terraform-aws-starter-kit/drop/' 
  yamlConfigFileAndPath = pathToApplicationRoot+ nameOfYamlConfigFile
else:  
  keySource = "keyFile"
  yamlConfigFileAndPath = dirOfYamlFile + nameOfYamlConfigFile
  pathToApplicationRoot = os.path.dirname(os.path.realpath(""))

print("Contents of application root directory are: ")
print(*Path(pathToApplicationRoot).iterdir(), sep="\n")

print("keySource is: ", keySource)

params = {
  'resGroupName': resourceGroupName,
  'storageAccountNameTerraformBackend': storageAccountName,
  'storContainerName': storageContainerName,
  'keyFileTF': 'replace-with-autogenerated-key' 
}

=======
else:  
  keySource = "keyFile"

print("keySource is: ", keySource)

>>>>>>> ac0a3b861b45a7306429e91c3896cc8010db9031

###############################################################################################
### Functions
###############################################################################################
<<<<<<< HEAD

def destroyTheVMs(pathToApplicationRoot, yamlConfigFileAndPath, yamlKeysFileAndPath, tfvarsFileAndPath, keySource, demoStorageKey, pub, sec, **kw):
  foundationInstanceName = depfunc.getFoundationInstanceName(yamlConfigFileAndPath)
  if platform.system() == 'Windows':
    destinationVirtualMachineCallParent = pathToApplicationRoot + "\\calls-to-modules\\instances\\vm\\"
  else:
    destinationVirtualMachineCallParent = pathToApplicationRoot + "/calls-to-modules/instances/vm/"
=======
def destroyTheVMs(pathToApplicationRoot, yamlConfigFileAndPath, yamlKeysFileAndPath, tfvarsFileAndPath, keySource, pub, sec):
  foundationInstanceName = depfunc.getFoundationInstanceName(yamlConfigFileAndPath)
  destinationVirtualMachineCallParent = pathToApplicationRoot + "\\calls-to-modules\\instances\\vm\\"
>>>>>>> ac0a3b861b45a7306429e91c3896cc8010db9031
  #Now iterate the VM instances and remove each instance both in the cloud and then locally.
  vmInstanceNames = depfunc.getVirtualMachineInstanceNames(yamlConfigFileAndPath)
  print("vmInstanceNames is: ", vmInstanceNames)
  for vmName in vmInstanceNames: 
    print("vmName is; ", vmName)
<<<<<<< HEAD
    destinationVirtualMachineCallInstance = depfunc.instantiateStandaloneVirtualMachineCallInstance(pathToApplicationRoot, yamlConfigFileAndPath, vmName, keySource, demoStorageKey, **kw)
=======
    destinationVirtualMachineCallInstance = destinationVirtualMachineCallParent+foundationInstanceName+"-"+vmName+"-vm\\"  
>>>>>>> ac0a3b861b45a7306429e91c3896cc8010db9031
    if os.path.exists(destinationVirtualMachineCallInstance) and os.path.isdir(destinationVirtualMachineCallInstance):
      ###
      ### Destroy The VM in cloud
      ###
      varsFragmentCompute = depfunc.getVarsFragmentVM(yamlConfigFileAndPath, yamlKeysFileAndPath, tfvarsFileAndPath, depfunc.vpc_id, depfunc.subnet_id, depfunc.sg_id, keySource, pub, sec)
      print("varsFragmentCompute for VM is: ", varsFragmentCompute)
      destroyCommandCompute = "terraform destroy -auto-approve" + varsFragmentCompute
      print("destroyCommandCompute is: ", destroyCommandCompute)
<<<<<<< HEAD
=======
      # dirToUseVM = pathToApplicationRoot + "calls-to-modules\\aws-simple-vm-call-to-module\\"
      initCommand = 'terraform init '
      depfunc.runTerraformCommand(initCommand, destinationVirtualMachineCallInstance)
>>>>>>> ac0a3b861b45a7306429e91c3896cc8010db9031
      depfunc.runTerraformCommand(destroyCommandCompute, destinationVirtualMachineCallInstance)  
      ### 
      ### Then destroy each instance of the calls to the vm modules in local agent file system
      ###
      if depfunc.terraformResult == "Destroyed": 
        print("Inside conditional block of things to do if destroy operation completed. ")
<<<<<<< HEAD
        depfunc.destroyInstanceOfCallToModule(destinationVirtualMachineCallInstance, destinationVirtualMachineCallParent)
=======
        #remove the instance of the call to the module, including its directory and any contents of that directory.  
        if os.path.exists(destinationVirtualMachineCallInstance) and os.path.isdir(destinationVirtualMachineCallInstance):
          #if not os.listdir(destinationVirtualMachineCallInstance):
          print("Directory is empty")
          path = Path(destinationVirtualMachineCallInstance)
          shutil.rmtree(path)
          #else:    
          #  print("Instance directory is not empty, so we will keep it for now:  ", destinationVirtualMachineCallInstance)
        else:
          print("Given Directory doesn't exist: ", destinationVirtualMachineCallInstance)
        #If parent is empty, delete parent directory also.  Otherwise, if parent directory is NOT empty, leave parent directory as-is.
        if os.path.exists(destinationVirtualMachineCallParent) and os.path.isdir(destinationVirtualMachineCallParent):
          if not os.listdir(destinationVirtualMachineCallParent):
            print("Directory is empty")
            path = Path(destinationVirtualMachineCallParent)
            shutil.rmtree(path)
          else:    
            print("Parent directory is not empty, so we will keep it for now: ", destinationVirtualMachineCallParent)
        else:
          print("Given Directory doesn't exist: ", destinationVirtualMachineCallParent)
>>>>>>> ac0a3b861b45a7306429e91c3896cc8010db9031
    else:  
      print("The VM specified as \"", vmName, "\" does not have any corresponding call to a module that might manage it.  Either it does not exist or it is outside the scope of this program.  Specifically, the following directory does not exist: ", destinationVirtualMachineCallInstance)
      print("Therefore, we are not processing the request to remove the vm: \"", vmName, "\"")

<<<<<<< HEAD
def getOutputFromFoundation(yamlConfigFileAndPath, pathToApplicationRoot, keySource, demoStorageKey, **kw):
  foundationInstanceName = depfunc.getFoundationInstanceName(yamlConfigFileAndPath)
  destinationFoundationCallInstance = depfunc.instantiateFoundationCallInstance(pathToApplicationRoot, yamlConfigFileAndPath, keySource, demoStorageKey, **kw)
  if platform.system() == 'Windows':
    destinationFoundationCallParent = pathToApplicationRoot + "\\calls-to-modules\\instances\\network-foundation\\"
  else:
    destinationFoundationCallParent = pathToApplicationRoot + "/calls-to-modules/instances/network-foundation/"
  # Get output from foundation
=======
def getOutputFromFoundation(yamlConfigFileAndPath, pathToApplicationRoot):
  foundationInstanceName = depfunc.getFoundationInstanceName(yamlConfigFileAndPath)
  # Get output from foundation
  destinationFoundationCallInstance = pathToApplicationRoot + "\\calls-to-modules\\instances\\network-foundation\\"+foundationInstanceName+"-network-foundation\\"  
  initCommand = 'terraform init '
  depfunc.runTerraformCommand(initCommand, destinationFoundationCallInstance)
>>>>>>> ac0a3b861b45a7306429e91c3896cc8010db9031
  outputCommand = 'terraform output '  
  depfunc.runTerraformCommand(outputCommand, destinationFoundationCallInstance)
  #Now delete the tfvars file because we only want keys in the yaml input
  #os.remove(tfvarsFileAndPath)
  print("New output from foundation should have populated the following 3 variables: ")
  print("depfunc.vpc_id is: ", depfunc.vpc_id) 
  print("depfunc.subnet_id is: ", depfunc.subnet_id) 
  print("depfunc.sg_id is: ", depfunc.sg_id)
<<<<<<< HEAD
  depfunc.destroyInstanceOfCallToModule(destinationFoundationCallInstance, destinationFoundationCallParent)

def destroyTheFoundation(yamlConfigFileAndPath, pathToApplicationRoot, yamlKeysFileAndPath, tfvarsFileAndPath, keySource, demoStorageKey, pub, sec, **kw):
=======

def destroyTheFoundation(yamlConfigFileAndPath, pathToApplicationRoot, yamlKeysFileAndPath, tfvarsFileAndPath, keySource, pub, sec):
>>>>>>> ac0a3b861b45a7306429e91c3896cc8010db9031
  ############################################################################
  ### Destroy the Network Foundation 
  ############################################################################
  foundationInstanceName = depfunc.getFoundationInstanceName(yamlConfigFileAndPath)
<<<<<<< HEAD
  if platform.system() == 'Windows':
    destinationFoundationCallParent = pathToApplicationRoot + "\\calls-to-modules\\instances\\network-foundation\\"
  else:
    destinationFoundationCallParent = pathToApplicationRoot + "/calls-to-modules/instances/network-foundation/"
  destinationFoundationCallInstance = depfunc.instantiateFoundationCallInstance(pathToApplicationRoot, yamlConfigFileAndPath, keySource, demoStorageKey, **kw)
=======
  destinationFoundationCallParent = pathToApplicationRoot + "\\calls-to-modules\\instances\\network-foundation\\"
  destinationFoundationCallInstance = destinationFoundationCallParent+foundationInstanceName+"-network-foundation\\"  
>>>>>>> ac0a3b861b45a7306429e91c3896cc8010db9031
  #\\NOTE: Pipeline version of this will create and use a remote backend.  But here in the demo laptop version we are using a local backend to keep it simple.
  varsFragmentNet = depfunc.getVarsFragmentFoundation(yamlConfigFileAndPath, yamlKeysFileAndPath, tfvarsFileAndPath, keySource, pub, sec)
  print("varsFragmentNet is: ", varsFragmentNet)  
  destroyCommandNet = "terraform destroy -auto-approve" + varsFragmentNet
  print("destroyCommandNet is: ", destroyCommandNet)
<<<<<<< HEAD
  print("destinationFoundationCallInstance is: ", destinationFoundationCallInstance)
  try: 
=======
  initCommand = 'terraform init '
  print("destinationFoundationCallInstance is: ", destinationFoundationCallInstance)
  try: 
    depfunc.runTerraformCommand(initCommand, destinationFoundationCallInstance)
>>>>>>> ac0a3b861b45a7306429e91c3896cc8010db9031
    depfunc.runTerraformCommand(destroyCommandNet, destinationFoundationCallInstance)
  except NotADirectoryError:
    print("Instance of call to module does not exist, so we will not do anything here now.")
  #Now delete the tfvars file because we only want keys in the yaml input
  os.remove(tfvarsFileAndPath)
  #######################################################################################
  ### Remove the instance of the call to module, but only if the Destroyed flag was set.  
  #######################################################################################
  if depfunc.terraformResult == "Destroyed": 
    print("Inside conditional block of things to do if destroy operation completed. ")
<<<<<<< HEAD
    depfunc.destroyInstanceOfCallToModule(destinationFoundationCallInstance, destinationFoundationCallParent)

def destroySecurityGroupRule(sgr, pathToApplicationRoot, foundationInstanceName, yamlConfigFileAndPath, yamlKeysFileAndPath, tfvarsFileAndPath, vpcId, vpcCidr, sgId, sgName, keySource, demoStorageKey, pub, sec, **kw):
  print("sgr is: ", sgr)
  destinationSecurityGroupRuleCallInstance = depfunc.instantiateSecurityGroupRuleCallInstance(pathToApplicationRoot, yamlConfigFileAndPath, sgr, keySource, demoStorageKey, **kw)
  if platform.system() == 'Windows':
    destinationSecurityGroupRuleCallParent = pathToApplicationRoot + "\\calls-to-modules\\instances\\security-group-rules\\"
  else:
    destinationSecurityGroupRuleCallParent = pathToApplicationRoot + "/calls-to-modules/instances/security-group-rules/"
=======
    #remove the instance of the call to the module, including its directory and any contents of that directory.  
    path = Path(destinationFoundationCallInstance)
    shutil.rmtree(path)
    #If parent is empty, delete parent directory also.  Otherwise, if parent directory is NOT empty, leave parent directory as-is.
    if os.path.exists(destinationFoundationCallParent) and os.path.isdir(destinationFoundationCallParent):
      if not os.listdir(destinationFoundationCallParent):
        print("Directory is empty")
        path = Path(destinationFoundationCallParent)
        shutil.rmtree(path)
      else:    
        print("Parent directory is not empty, so we will keep it for now.  ")
    else:
      print("Given Directory doesn't exists")

def destroySecurityGroupRule(sgr, pathToApplicationRoot, foundationInstanceName, yamlConfigFileAndPath, yamlKeysFileAndPath, tfvarsFileAndPath, vpcId, vpcCidr, sgId, sgName, destinationSecurityGroupRuleCallParent, keySource, pub, sec):
  print("sgr is: ", sgr)
  destinationSecurityGroupRuleCallInstance = pathToApplicationRoot + "\\calls-to-modules\\instances\\security-group-rules\\"+foundationInstanceName+"-"+sgr+"-sgr\\"  
>>>>>>> ac0a3b861b45a7306429e91c3896cc8010db9031
  if os.path.exists(destinationSecurityGroupRuleCallInstance) and os.path.isdir(destinationSecurityGroupRuleCallInstance):
    print("destinationSecurityGroupRuleCallInstance is: ", destinationSecurityGroupRuleCallInstance)
    ### 
    ### Fist destroy the security group rules in the cloud
    ### 
    varsFragmentSG = depfunc.getVarsFragmentSecurityGroup(sgr, yamlConfigFileAndPath, yamlKeysFileAndPath, tfvarsFileAndPath, vpcId, vpcCidr, sgId, sgName, keySource, pub, sec)  
    print("varsFragmentSG is: ", varsFragmentSG)
    destroyCommandSG = "terraform destroy -auto-approve" + varsFragmentSG
    print("destroyCommandSG is: ", destroyCommandSG)
<<<<<<< HEAD
=======
    #dirToUseSG = pathToApplicationRoot + "calls-to-modules\\aws-simple-security-group-rules-call-to-module\\"
    initCommand = 'terraform init '
    depfunc.runTerraformCommand(initCommand, destinationSecurityGroupRuleCallInstance)
>>>>>>> ac0a3b861b45a7306429e91c3896cc8010db9031
    depfunc.runTerraformCommand(destroyCommandSG, destinationSecurityGroupRuleCallInstance)
    ### 
    ### Then destroy each instance of the calls to the sgr modules in local agent file system
    ###
<<<<<<< HEAD
    if depfunc.terraformResult == "Destroyed": 
      print("Inside conditional block of things to do if destroy operation completed. ")
      #remove the instance of the call to the module, including its directory and any contents of that directory.  
      depfunc.destroyInstanceOfCallToModule(destinationSecurityGroupRuleCallInstance, destinationSecurityGroupRuleCallParent)
=======
    #if depfunc.terraformResult == "Destroyed": 
    #  print("Inside conditional block of things to do if destroy operation completed. ")
    #remove the instance of the call to the module, including its directory and any contents of that directory.  
    if os.path.exists(destinationSecurityGroupRuleCallInstance) and os.path.isdir(destinationSecurityGroupRuleCallInstance):
      #if not os.listdir(destinationVirtualMachineCallInstance):
      print("Directory is empty")
      path = Path(destinationSecurityGroupRuleCallInstance)
      shutil.rmtree(path)
      #else:    
      #  print("Instance directory is not empty, so we will keep it for now:  ", destinationVirtualMachineCallInstance)
    else:
      print("Given Directory doesn't exist: ", destinationSecurityGroupRuleCallInstance)
    #If parent is empty, delete parent directory also.  Otherwise, if parent directory is NOT empty, leave parent directory as-is.
    if os.path.exists(destinationSecurityGroupRuleCallParent) and os.path.isdir(destinationSecurityGroupRuleCallParent):
      if not os.listdir(destinationSecurityGroupRuleCallParent):
        print("Directory is empty")
        path = Path(destinationSecurityGroupRuleCallParent)
        shutil.rmtree(path)
      else:    
        print("Parent directory is not empty, so we will keep it for now: ", destinationSecurityGroupRuleCallParent)
    else:
      print("Given Directory doesn't exist: ", destinationSecurityGroupRuleCallParent)
>>>>>>> ac0a3b861b45a7306429e91c3896cc8010db9031
  else:
    print("There is no instance of a call to the security group rule module in any directory by the following name: ", destinationSecurityGroupRuleCallInstance)
    print("Add better error handling here based on the rules your organization defines. ")

<<<<<<< HEAD
def destroyTheBlobStorageInstance(blobStorageInstance, pathToApplicationRoot, foundationInstanceName, yamlConfigFileAndPath, yamlKeysFileAndPath, tfvarsFileAndPath, vpcId, keySource, pub, sec, demoStorageKey, **kw):
  print("inside destroyTheBlobStorageInstance(), blobStorageInstance is: ", blobStorageInstance)
  ### 
  ### Create an instance of the call to the module in the local agent file system for terraform to use in the next step.  
  ### 
  destinationBlobStorageCallInstance = depfunc.instantiateBlobStorageCallInstance(pathToApplicationRoot, yamlConfigFileAndPath, blobStorageInstance, keySource, demoStorageKey, **kw)
  if platform.system() == 'Windows':
    destinationBlobStorageCallParent = pathToApplicationRoot + "\\calls-to-modules\\instances\\s3-backends\\"
  else:
    destinationBlobStorageCallParent = pathToApplicationRoot + "/calls-to-modules/instances/s3-backends/"
  if os.path.exists(destinationBlobStorageCallInstance) and os.path.isdir(destinationBlobStorageCallInstance):
    print("destinationBlobStorageCallInstance is: ", destinationBlobStorageCallInstance)
    ### 
    ### Then destroy the blobStorage instance in the cloud.  Note you have to empty the bucket first before terraform will allow you to delete it.  This has the potential to leave orphaned buckets in the cloud, which you will have to manage somehow.  
=======
def destroyTheBlobStorageInstance(blobStorageInstance, pathToApplicationRoot, foundationInstanceName, yamlConfigFileAndPath, yamlKeysFileAndPath, tfvarsFileAndPath, vpcId, keySource, pub, sec):
  print("inside destroyTheBlobStorageInstance(), blobStorageInstance is: ", blobStorageInstance)
  destinationBlobStorageCallParent = pathToApplicationRoot + "\\calls-to-modules\\instances\\s3-backends\\"
  destinationBlobStorageCallInstance = destinationBlobStorageCallParent +foundationInstanceName+"-"+blobStorageInstance+"-s3\\"  
  #"\\calls-to-modules\\instances\\s3-backends\\"+foundationInstanceName+"-"+s3Instance+"-s3\\"  
  if os.path.exists(destinationBlobStorageCallInstance) and os.path.isdir(destinationBlobStorageCallInstance):
    print("destinationBlobStorageCallInstance is: ", destinationBlobStorageCallInstance)
    ### 
    ### Fist destroy the blobStorage instance in the cloud.  Note you have to empty the bucket first before terraform will allow you to delete it.  This has the potential to leave orphaned buckets in the cloud, which you will have to manage somehow.  
>>>>>>> ac0a3b861b45a7306429e91c3896cc8010db9031
    ### 
    varsFragmentBlobStorage = depfunc.getVarsFragmentBlobStorage(blobStorageInstance, yamlConfigFileAndPath, yamlKeysFileAndPath, tfvarsFileAndPath, vpcId, keySource, pub, sec)  
    print("varsFragmentBlobStorage is: ", varsFragmentBlobStorage)
    print("----------------------------------------------------------------------------------")
    destroyCommandBlobStorage = "terraform destroy -auto-approve" + varsFragmentBlobStorage
    print("destroyCommandBlobStorage is: ", destroyCommandBlobStorage)
<<<<<<< HEAD
=======
    initCommand = 'terraform init '
    depfunc.runTerraformCommand(initCommand, destinationBlobStorageCallInstance)
>>>>>>> ac0a3b861b45a7306429e91c3896cc8010db9031
    depfunc.runTerraformCommand(destroyCommandBlobStorage, destinationBlobStorageCallInstance)
    print("depfunc.terraformResult is: ", depfunc.terraformResult)

    if depfunc.terraformResult == "Destroyed":
      print("Inside the block only to be performed after the destroy operation was successfully completed by Terraform.  ")
      ### 
      ### Then destroy each instance of the calls to the blobStorage modules in local agent file system
      ### 
<<<<<<< HEAD
      #remove the instance of the call to the module, including its directory and any contents of that directory.  
      depfunc.destroyInstanceOfCallToModule(destinationBlobStorageCallInstance, destinationBlobStorageCallParent)
=======
      ###
      #remove the instance of the call to the module, including its directory and any contents of that directory.  
      if os.path.exists(destinationBlobStorageCallInstance) and os.path.isdir(destinationBlobStorageCallInstance):
        #if not os.listdir(destinationS3CallInstance):
        print("Directory is empty.  About to delete: ", destinationBlobStorageCallInstance)
        path = Path(destinationBlobStorageCallInstance)
        shutil.rmtree(path)
        #else:    
        #  print("Instance directory is not empty, so we will keep it for now:  ", destinationVirtualMachineCallInstance)
      else:
        print("Given Directory doesn't exist: ", destinationBlobStorageCallInstance)
      #If parent is empty, delete parent directory also.  Otherwise, if parent directory is NOT empty, leave parent directory as-is.
      if os.path.exists(destinationBlobStorageCallParent) and os.path.isdir(destinationBlobStorageCallParent):
        if not os.listdir(destinationBlobStorageCallParent):
          print("Directory is empty")
          path = Path(destinationBlobStorageCallParent)
          shutil.rmtree(path)
        else:    
          print("Parent directory is not empty, so we will keep it for now: ", destinationBlobStorageCallParent)
      else:
        print("Given Directory doesn't exist: ", destinationBlobStorageCallParent)
>>>>>>> ac0a3b861b45a7306429e91c3896cc8010db9031
  else:
    print("There is no instance of a call to the blobStorage module in any directory by the following name: ", destinationBlobStorageCallInstance)
    print("Add better error handling here based on the rules your organization defines. ")

<<<<<<< HEAD
#############################################################################
### Get Output Variables From Foundation Module Instance
#############################################################################
getOutputFromFoundation(yamlConfigFileAndPath, pathToApplicationRoot, keySource, demoStorageKey, **params)

################################################################################
### Destroy blobStorage Backend that are attached to the foundation
################################################################################
=======

#############################################################################
### Import path locations relative to application root
#############################################################################
app_parent_path = os.path.dirname(os.path.realpath("..\\"))
dirOfYamlFile = app_parent_path+"\\config-and-secrets-outside-app-path\\" + "vars\\yamlInputs\\"
nameOfYamlConfigFile = 'varsFromDevLaptop.yaml'
yamlConfigFileAndPath = dirOfYamlFile + nameOfYamlConfigFile
nameOfYamlKeysFile = 'keys.yaml'
yamlKeysFileAndPath = dirOfYamlFile + nameOfYamlKeysFile 
pathToApplicationRoot = os.path.dirname(os.path.realpath(""))
dirOfTfvarsFile = app_parent_path+"\\config-and-secrets-outside-app-path\\vars\\VarsForTerraform\\"
nameOfTfvarsFile = 'keys.tfvars'
tfvarsFileAndPath = dirOfTfvarsFile + nameOfTfvarsFile


#############################################################################
### Get Output Variables From Foundation Module Instance
#############################################################################
getOutputFromFoundation(yamlConfigFileAndPath, pathToApplicationRoot)

################################################################################
### Create blobStorage Backend and attach to the foundation
################################################################################
#Get some input vars from output from the network foundation module.  
#depfunc.runTerraformCommand('terraform output', dirToUseNet)
>>>>>>> ac0a3b861b45a7306429e91c3896cc8010db9031
foundationInstanceName = depfunc.getFoundationInstanceName(yamlConfigFileAndPath)
print("For blobStorage: depfunc.vpc_id is: ", depfunc.vpc_id) 
blobStorageInstanceNames = depfunc.getBlobStorageInstanceNames(yamlConfigFileAndPath)
print("blobStorageInstanceNames is:", blobStorageInstanceNames)
for blobStorageInstance in blobStorageInstanceNames:
<<<<<<< HEAD
  destroyTheBlobStorageInstance(blobStorageInstance, pathToApplicationRoot, foundationInstanceName, yamlConfigFileAndPath, yamlKeysFileAndPath, tfvarsFileAndPath, depfunc.vpc_id, keySource, pub, sec, demoStorageKey, **params)
=======
  destroyTheBlobStorageInstance(blobStorageInstance, pathToApplicationRoot, foundationInstanceName, yamlConfigFileAndPath, yamlKeysFileAndPath, tfvarsFileAndPath, depfunc.vpc_id, keySource, pub, sec)


>>>>>>> ac0a3b861b45a7306429e91c3896cc8010db9031

##############################################################################
### Destroy the Security Group Rules then destroy their call instances one by one
##############################################################################
foundationInstanceName = depfunc.getFoundationInstanceName(yamlConfigFileAndPath)
<<<<<<< HEAD
=======
destinationSecurityGroupRuleCallParent = pathToApplicationRoot + "\\calls-to-modules\\instances\\security-group-rules\\"
>>>>>>> ac0a3b861b45a7306429e91c3896cc8010db9031
sgrInstanceNames = depfunc.getSecurityGroupRuleInstanceNames(yamlConfigFileAndPath) 
print("sgrInstanceNames is: ", sgrInstanceNames)
for sgr in sgrInstanceNames:
  #Get some input vars from output from the network foundation module.  
  print("depfunc.vpc_id is: ", depfunc.vpc_id) 
  print("depfunc.vpc_cidr is: ", depfunc.vpc_cidr)
  print("depfunc.sg_id is: ", depfunc.sg_id)
  print("depfunc.sg_name is: ", depfunc.sg_name)
<<<<<<< HEAD
  destroySecurityGroupRule(sgr, pathToApplicationRoot, foundationInstanceName, yamlConfigFileAndPath, yamlKeysFileAndPath, tfvarsFileAndPath, depfunc.vpc_id, depfunc.vpc_cidr, depfunc.sg_id, depfunc.sg_name, keySource, demoStorageKey, pub, sec, **params)
=======
  destroySecurityGroupRule(sgr, pathToApplicationRoot, foundationInstanceName, yamlConfigFileAndPath, yamlKeysFileAndPath, tfvarsFileAndPath, depfunc.vpc_id, depfunc.vpc_cidr, depfunc.sg_id, depfunc.sg_name, destinationSecurityGroupRuleCallParent, keySource, pub, sec)
>>>>>>> ac0a3b861b45a7306429e91c3896cc8010db9031

##############################################################################
### Destroy the Virtual Machines then destroy their call instances one by one
##############################################################################
<<<<<<< HEAD
destroyTheVMs(pathToApplicationRoot, yamlConfigFileAndPath, yamlKeysFileAndPath, tfvarsFileAndPath, keySource, demoStorageKey, pub, sec, **params)
=======
destroyTheVMs(pathToApplicationRoot, yamlConfigFileAndPath, yamlKeysFileAndPath, tfvarsFileAndPath, keySource, pub, sec)
>>>>>>> ac0a3b861b45a7306429e91c3896cc8010db9031

##########################################################################################
### Destroy the Network Foundation and the Instance of the Call To The Foundation Module
##########################################################################################
<<<<<<< HEAD
destroyTheFoundation(yamlConfigFileAndPath, pathToApplicationRoot, yamlKeysFileAndPath, tfvarsFileAndPath, keySource, demoStorageKey, pub, sec, **params)

=======
destroyTheFoundation(yamlConfigFileAndPath, pathToApplicationRoot, yamlKeysFileAndPath, tfvarsFileAndPath, keySource, pub, sec)

#\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
#///////////////////////////////////////////////////////////////
# BELOW HERE IS OBSOLETE OLD AND TO BE REMOVED.
#\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
#///////////////////////////////////////////////////////////////

# ################################################################################
# ### Destroy the S3 Backend 
# ################################################################################
# #Get some input vars from output from the network foundation module.  
# depfunc.runTerraformCommand('terraform output', dirToUseNet)
# print("depfunc.vpc_id is: ", depfunc.vpc_id) 
# varsFragmentS3Backend = depfunc.getVarsFragmentS3Backend(yamlConfigFileAndPath, depfunc.vpc_id)
# print("varsFragmentS3Backend is: ", varsFragmentS3Backend)
# destroyCommandS3Backend = "terraform destroy -auto-approve" + varsFragmentS3Backend
# print("destroyCommandS3Backend is: ", destroyCommandS3Backend)
# depfunc.runTerraformCommand(initCommand, dirToUseS3Backend)
# depfunc.runTerraformCommand(destroyCommandS3Backend, dirToUseS3Backend)

# #############################################################################
# ### Destroy the security group rule
# #############################################################################
# #Get some input vars from output from the network foundation module.  
# depfunc.runTerraformCommand('terraform output', dirToUseNet)
# print("depfunc.vpc_id is: ", depfunc.vpc_id) 
# print("depfunc.vpc_cidr is: ", depfunc.vpc_cidr)
# print("depfunc.sg_id is: ", depfunc.sg_id)
# print("depfunc.sg_name is: ", depfunc.sg_name)
# varsFragmentSG = depfunc.getVarsFragmentSecurityGroup(yamlConfigFileAndPath, depfunc.vpc_id, depfunc.vpc_cidr, depfunc.sg_id, depfunc.sg_name)  
# print("varsFragmentSG is: ", varsFragmentSG)
# destroyCommandSG = "terraform destroy -auto-approve" + varsFragmentSG
# print("destroyCommandSG is: ", destroyCommandSG)
# depfunc.runTerraformCommand(initCommand, dirToUseSG)
# depfunc.runTerraformCommand(destroyCommandSG, dirToUseSG)

# ###############################################################################
# ### Destroy the virtual machine
# ###############################################################################
# #Get some input vars from output from the network foundation module.  
# depfunc.runTerraformCommand('terraform output', dirToUseNet)
# print("depfunc.vpc_id is: ", depfunc.vpc_id) 
# print("depfunc.subnet_id is: ", depfunc.subnet_id) 
# print("depfunc.sg_id is: ", depfunc.sg_id)
# varsFragmentCompute = depfunc.getVarsFragmentVM(yamlConfigFileAndPath, depfunc.vpc_id, depfunc.subnet_id, depfunc.sg_id)  
# print("varsFragmentCompute for VM is: ", varsFragmentCompute)
# destroyCommandCompute = "terraform destroy -auto-approve" + varsFragmentCompute
# print("destroyCommandCompute is: ", destroyCommandCompute)
# depfunc.runTerraformCommand(initCommand, dirToUseVM)
# depfunc.runTerraformCommand(destroyCommandCompute, dirToUseVM)  

# ###############################################################################
# ### Destroy the foundation 
# ###############################################################################
# varsFragmentNet = depfunc.getVarsFragmentFoundation(yamlConfigFileAndPath)
# print("varsFragmentNet is: ", varsFragmentNet)  
# destroyCommandNet = "terraform destroy -auto-approve" + varsFragmentNet
# print("destroyCommandNet is: ", destroyCommandNet)
# depfunc.runTerraformCommand(initCommand, dirToUseNet)
# depfunc.runTerraformCommand(destroyCommandNet, dirToUseNet)
>>>>>>> ac0a3b861b45a7306429e91c3896cc8010db9031
