## Copyright 2020 Green River IT (GreenRiverIT.com) as described in LICENSE.txt distributed with this project on GitHub.  
## Start at https://github.com/AgileCloudInstitute?tab=repositories    

import deploymentFunctions as depfunc
import os
from distutils.dir_util import copy_tree
from pathlib import Path
import platform
import shutil
import sys

#############################################################################
### Import path locations relative to application root
#############################################################################
app_parent_path = os.path.dirname(os.path.realpath("..\\"))
dirOfYamlFile = app_parent_path+"\\config-and-secrets-outside-app-path\\" + "vars\\yamlInputs\\"
nameOfYamlConfigFile = 'demoConfig.yaml'
nameOfYamlKeysFile = 'keys.yaml'
yamlKeysFileAndPath = dirOfYamlFile + nameOfYamlKeysFile 
pathToApplicationRoot = ''  

tfvarsFileAndPath=''

#############################################################################
### Import variable values, including CLI arguments if from pipeline
#############################################################################
if platform.system() == 'Windows':
  dirOfTfvarsFile = app_parent_path+"\\config-and-secrets-outside-app-path\\vars\\VarsForTerraform\\"
  nameOfTfvarsFile = 'keys.tfvars'
  tfvarsFileAndPath = dirOfTfvarsFile + nameOfTfvarsFile

else:
  #Consider whether to give a separate variable for the name of each secret file, as in the next line, or alternatively to repopulate the same variable each time as shown in the line that follows the next line.  
  tfvarsFileAndPath = '/home/azureuser/' + 'foundationSecrets.tfvars'

#The following 7 variables only need to be declared if a pipeline ingests this.  Some of the following will be repopulated by the pipeline inputs.  
keySource=''
yamlConfigFileAndPath = ""
pub = "empty"
sec = "empty"
resourceGroupName="pipeline-resources" 
storageAccountName=''
storageContainerName="tfcontainer"
demoStorageKey=''

#Ingest pipeline variables if they are present
print("len(sys.argv) is: ", len(sys.argv))
if len(sys.argv) > 1:  
  keySource=sys.argv[1]
  if keySource != "keyVault":
    print("keySource is NOT set to a valid value.  ")
  # the build config distributed with this repo put the yaml file in the following location for use by pipelines:
  nameOfYamlConfigFile=sys.argv[2]
  pub=sys.argv[3]
  sec=sys.argv[4]
  storageAccountName=sys.argv[5]
  demoStorageKey=sys.argv[6]
  #Next we make the path to application root depend on the DefaultWorkingDirectory from the pipeline agent.  Assuming a linux agent
  pathToApplicationRoot=sys.argv[7] + '/_terraform-aws-starter-kit/drop/' 
  yamlConfigFileAndPath = pathToApplicationRoot+ nameOfYamlConfigFile
else:  
  keySource = "keyFile"
  yamlConfigFileAndPath = dirOfYamlFile + nameOfYamlConfigFile
  pathToApplicationRoot = os.path.dirname(os.path.realpath(""))

print("Contents of application root directory are: ")
print(*Path(pathToApplicationRoot).iterdir(), sep="\n")

print("keySource is: ", keySource)

params = {
  'resGroupName': resourceGroupName,
  'storageAccountNameTerraformBackend': storageAccountName,
  'storContainerName': storageContainerName,
  'keyFileTF': 'replace-with-autogenerated-key' 
}


###############################################################################################
### Functions
###############################################################################################

def destroyTheVMs(pathToApplicationRoot, yamlConfigFileAndPath, yamlKeysFileAndPath, tfvarsFileAndPath, keySource, demoStorageKey, pub, sec, **kw):
  foundationInstanceName = depfunc.getFoundationInstanceName(yamlConfigFileAndPath)
  if platform.system() == 'Windows':
    destinationVirtualMachineCallParent = pathToApplicationRoot + "\\calls-to-modules\\instances\\vm\\"
  else:
    destinationVirtualMachineCallParent = pathToApplicationRoot + "/calls-to-modules/instances/vm/"
  #Now iterate the VM instances and remove each instance both in the cloud and then locally.
  vmInstanceNames = depfunc.getVirtualMachineInstanceNames(yamlConfigFileAndPath)
  print("vmInstanceNames is: ", vmInstanceNames)
  for vmName in vmInstanceNames: 
    print("vmName is; ", vmName)
    destinationVirtualMachineCallInstance = depfunc.instantiateStandaloneVirtualMachineCallInstance(pathToApplicationRoot, yamlConfigFileAndPath, vmName, keySource, demoStorageKey, **kw)
    if os.path.exists(destinationVirtualMachineCallInstance) and os.path.isdir(destinationVirtualMachineCallInstance):
      ###
      ### Destroy The VM in cloud
      ###
      varsFragmentCompute = depfunc.getVarsFragmentVM(yamlConfigFileAndPath, yamlKeysFileAndPath, tfvarsFileAndPath, depfunc.vpc_id, depfunc.subnet_id, depfunc.sg_id, keySource, pub, sec)
      print("varsFragmentCompute for VM is: ", varsFragmentCompute)
      destroyCommandCompute = "terraform destroy -auto-approve" + varsFragmentCompute
      print("destroyCommandCompute is: ", destroyCommandCompute)
      depfunc.runTerraformCommand(destroyCommandCompute, destinationVirtualMachineCallInstance)  
      ### 
      ### Then destroy each instance of the calls to the vm modules in local agent file system
      ###
      if depfunc.terraformResult == "Destroyed": 
        print("Inside conditional block of things to do if destroy operation completed. ")
        depfunc.destroyInstanceOfCallToModule(destinationVirtualMachineCallInstance, destinationVirtualMachineCallParent)
    else:  
      print("The VM specified as \"", vmName, "\" does not have any corresponding call to a module that might manage it.  Either it does not exist or it is outside the scope of this program.  Specifically, the following directory does not exist: ", destinationVirtualMachineCallInstance)
      print("Therefore, we are not processing the request to remove the vm: \"", vmName, "\"")

def getOutputFromFoundation(yamlConfigFileAndPath, pathToApplicationRoot, keySource, demoStorageKey, **kw):
  foundationInstanceName = depfunc.getFoundationInstanceName(yamlConfigFileAndPath)
  destinationFoundationCallInstance = depfunc.instantiateFoundationCallInstance(pathToApplicationRoot, yamlConfigFileAndPath, keySource, demoStorageKey, **kw)
  if platform.system() == 'Windows':
    destinationFoundationCallParent = pathToApplicationRoot + "\\calls-to-modules\\instances\\network-foundation\\"
  else:
    destinationFoundationCallParent = pathToApplicationRoot + "/calls-to-modules/instances/network-foundation/"
  # Get output from foundation
  outputCommand = 'terraform output '  
  depfunc.runTerraformCommand(outputCommand, destinationFoundationCallInstance)
  #Now delete the tfvars file because we only want keys in the yaml input
  #os.remove(tfvarsFileAndPath)
  print("New output from foundation should have populated the following 3 variables: ")
  print("depfunc.vpc_id is: ", depfunc.vpc_id) 
  print("depfunc.subnet_id is: ", depfunc.subnet_id) 
  print("depfunc.sg_id is: ", depfunc.sg_id)
  depfunc.destroyInstanceOfCallToModule(destinationFoundationCallInstance, destinationFoundationCallParent)

def destroyTheFoundation(yamlConfigFileAndPath, pathToApplicationRoot, yamlKeysFileAndPath, tfvarsFileAndPath, keySource, demoStorageKey, pub, sec, **kw):
  ############################################################################
  ### Destroy the Network Foundation 
  ############################################################################
  foundationInstanceName = depfunc.getFoundationInstanceName(yamlConfigFileAndPath)
  if platform.system() == 'Windows':
    destinationFoundationCallParent = pathToApplicationRoot + "\\calls-to-modules\\instances\\network-foundation\\"
  else:
    destinationFoundationCallParent = pathToApplicationRoot + "/calls-to-modules/instances/network-foundation/"
  destinationFoundationCallInstance = depfunc.instantiateFoundationCallInstance(pathToApplicationRoot, yamlConfigFileAndPath, keySource, demoStorageKey, **kw)
  #\\NOTE: Pipeline version of this will create and use a remote backend.  But here in the demo laptop version we are using a local backend to keep it simple.
  varsFragmentNet = depfunc.getVarsFragmentFoundation(yamlConfigFileAndPath, yamlKeysFileAndPath, tfvarsFileAndPath, keySource, pub, sec)
  print("varsFragmentNet is: ", varsFragmentNet)  
  destroyCommandNet = "terraform destroy -auto-approve" + varsFragmentNet
  print("destroyCommandNet is: ", destroyCommandNet)
  print("destinationFoundationCallInstance is: ", destinationFoundationCallInstance)
  try: 
    depfunc.runTerraformCommand(destroyCommandNet, destinationFoundationCallInstance)
  except NotADirectoryError:
    print("Instance of call to module does not exist, so we will not do anything here now.")
  #Now delete the tfvars file because we only want keys in the yaml input
  os.remove(tfvarsFileAndPath)
  #######################################################################################
  ### Remove the instance of the call to module, but only if the Destroyed flag was set.  
  #######################################################################################
  if depfunc.terraformResult == "Destroyed": 
    print("Inside conditional block of things to do if destroy operation completed. ")
    depfunc.destroyInstanceOfCallToModule(destinationFoundationCallInstance, destinationFoundationCallParent)

def destroySecurityGroupRule(sgr, pathToApplicationRoot, foundationInstanceName, yamlConfigFileAndPath, yamlKeysFileAndPath, tfvarsFileAndPath, vpcId, vpcCidr, sgId, sgName, keySource, demoStorageKey, pub, sec, **kw):
  print("sgr is: ", sgr)
  destinationSecurityGroupRuleCallInstance = depfunc.instantiateSecurityGroupRuleCallInstance(pathToApplicationRoot, yamlConfigFileAndPath, sgr, keySource, demoStorageKey, **kw)
  if platform.system() == 'Windows':
    destinationSecurityGroupRuleCallParent = pathToApplicationRoot + "\\calls-to-modules\\instances\\security-group-rules\\"
  else:
    destinationSecurityGroupRuleCallParent = pathToApplicationRoot + "/calls-to-modules/instances/security-group-rules/"
  if os.path.exists(destinationSecurityGroupRuleCallInstance) and os.path.isdir(destinationSecurityGroupRuleCallInstance):
    print("destinationSecurityGroupRuleCallInstance is: ", destinationSecurityGroupRuleCallInstance)
    ### 
    ### Fist destroy the security group rules in the cloud
    ### 
    varsFragmentSG = depfunc.getVarsFragmentSecurityGroup(sgr, yamlConfigFileAndPath, yamlKeysFileAndPath, tfvarsFileAndPath, vpcId, vpcCidr, sgId, sgName, keySource, pub, sec)  
    print("varsFragmentSG is: ", varsFragmentSG)
    destroyCommandSG = "terraform destroy -auto-approve" + varsFragmentSG
    print("destroyCommandSG is: ", destroyCommandSG)
    depfunc.runTerraformCommand(destroyCommandSG, destinationSecurityGroupRuleCallInstance)
    ### 
    ### Then destroy each instance of the calls to the sgr modules in local agent file system
    ###
    if depfunc.terraformResult == "Destroyed": 
      print("Inside conditional block of things to do if destroy operation completed. ")
      #remove the instance of the call to the module, including its directory and any contents of that directory.  
      depfunc.destroyInstanceOfCallToModule(destinationSecurityGroupRuleCallInstance, destinationSecurityGroupRuleCallParent)
  else:
    print("There is no instance of a call to the security group rule module in any directory by the following name: ", destinationSecurityGroupRuleCallInstance)
    print("Add better error handling here based on the rules your organization defines. ")

def destroyTheBlobStorageInstance(blobStorageInstance, pathToApplicationRoot, foundationInstanceName, yamlConfigFileAndPath, yamlKeysFileAndPath, tfvarsFileAndPath, vpcId, keySource, pub, sec, demoStorageKey, **kw):
  print("inside destroyTheBlobStorageInstance(), blobStorageInstance is: ", blobStorageInstance)
  ### 
  ### Create an instance of the call to the module in the local agent file system for terraform to use in the next step.  
  ### 
  destinationBlobStorageCallInstance = depfunc.instantiateBlobStorageCallInstance(pathToApplicationRoot, yamlConfigFileAndPath, blobStorageInstance, keySource, demoStorageKey, **kw)
  if platform.system() == 'Windows':
    destinationBlobStorageCallParent = pathToApplicationRoot + "\\calls-to-modules\\instances\\s3-backends\\"
  else:
    destinationBlobStorageCallParent = pathToApplicationRoot + "/calls-to-modules/instances/s3-backends/"
  if os.path.exists(destinationBlobStorageCallInstance) and os.path.isdir(destinationBlobStorageCallInstance):
    print("destinationBlobStorageCallInstance is: ", destinationBlobStorageCallInstance)
    ### 
    ### Then destroy the blobStorage instance in the cloud.  Note you have to empty the bucket first before terraform will allow you to delete it.  This has the potential to leave orphaned buckets in the cloud, which you will have to manage somehow.  
    ### 
    varsFragmentBlobStorage = depfunc.getVarsFragmentBlobStorage(blobStorageInstance, yamlConfigFileAndPath, yamlKeysFileAndPath, tfvarsFileAndPath, vpcId, keySource, pub, sec)  
    print("varsFragmentBlobStorage is: ", varsFragmentBlobStorage)
    print("----------------------------------------------------------------------------------")
    destroyCommandBlobStorage = "terraform destroy -auto-approve" + varsFragmentBlobStorage
    print("destroyCommandBlobStorage is: ", destroyCommandBlobStorage)
    depfunc.runTerraformCommand(destroyCommandBlobStorage, destinationBlobStorageCallInstance)
    print("depfunc.terraformResult is: ", depfunc.terraformResult)

    if depfunc.terraformResult == "Destroyed":
      print("Inside the block only to be performed after the destroy operation was successfully completed by Terraform.  ")
      ### 
      ### Then destroy each instance of the calls to the blobStorage modules in local agent file system
      ### 
      #remove the instance of the call to the module, including its directory and any contents of that directory.  
      depfunc.destroyInstanceOfCallToModule(destinationBlobStorageCallInstance, destinationBlobStorageCallParent)
  else:
    print("There is no instance of a call to the blobStorage module in any directory by the following name: ", destinationBlobStorageCallInstance)
    print("Add better error handling here based on the rules your organization defines. ")

#############################################################################
### Get Output Variables From Foundation Module Instance
#############################################################################
getOutputFromFoundation(yamlConfigFileAndPath, pathToApplicationRoot, keySource, demoStorageKey, **params)

################################################################################
### Destroy blobStorage Backend that are attached to the foundation
################################################################################
foundationInstanceName = depfunc.getFoundationInstanceName(yamlConfigFileAndPath)
print("For blobStorage: depfunc.vpc_id is: ", depfunc.vpc_id) 
blobStorageInstanceNames = depfunc.getBlobStorageInstanceNames(yamlConfigFileAndPath)
print("blobStorageInstanceNames is:", blobStorageInstanceNames)
for blobStorageInstance in blobStorageInstanceNames:
  destroyTheBlobStorageInstance(blobStorageInstance, pathToApplicationRoot, foundationInstanceName, yamlConfigFileAndPath, yamlKeysFileAndPath, tfvarsFileAndPath, depfunc.vpc_id, keySource, pub, sec, demoStorageKey, **params)

##############################################################################
### Destroy the Security Group Rules then destroy their call instances one by one
##############################################################################
foundationInstanceName = depfunc.getFoundationInstanceName(yamlConfigFileAndPath)
sgrInstanceNames = depfunc.getSecurityGroupRuleInstanceNames(yamlConfigFileAndPath) 
print("sgrInstanceNames is: ", sgrInstanceNames)
for sgr in sgrInstanceNames:
  #Get some input vars from output from the network foundation module.  
  print("depfunc.vpc_id is: ", depfunc.vpc_id) 
  print("depfunc.vpc_cidr is: ", depfunc.vpc_cidr)
  print("depfunc.sg_id is: ", depfunc.sg_id)
  print("depfunc.sg_name is: ", depfunc.sg_name)
  destroySecurityGroupRule(sgr, pathToApplicationRoot, foundationInstanceName, yamlConfigFileAndPath, yamlKeysFileAndPath, tfvarsFileAndPath, depfunc.vpc_id, depfunc.vpc_cidr, depfunc.sg_id, depfunc.sg_name, keySource, demoStorageKey, pub, sec, **params)

##############################################################################
### Destroy the Virtual Machines then destroy their call instances one by one
##############################################################################
destroyTheVMs(pathToApplicationRoot, yamlConfigFileAndPath, yamlKeysFileAndPath, tfvarsFileAndPath, keySource, demoStorageKey, pub, sec, **params)

##########################################################################################
### Destroy the Network Foundation and the Instance of the Call To The Foundation Module
##########################################################################################
destroyTheFoundation(yamlConfigFileAndPath, pathToApplicationRoot, yamlKeysFileAndPath, tfvarsFileAndPath, keySource, demoStorageKey, pub, sec, **params)
